## 分布式架构

#### CAP理论

1. **一致性（Consistency）：** 这意味着在分布式系统中，如果一个节点修改了数据，那么其他所有节点在一定时间内也都能读到这个修改后的数据。即使在并发操作和节点故障的情况下，系统也能保证数据的一致性。
2. **可用性（Availability）：** 这表示分布式系统在任何时刻都能提供数据访问和服务。即使系统中的某些节点发生故障或不可用，仍然能够继续为用户提供服务。
3. **分区容忍性（Partition Tolerance）：** 这指的是分布式系统能够在网络分区（即网络通信失败导致节点间无法相互通信）的情况下继续工作。系统能够容忍网络中断或节点故障，并继续保持数据的一致性和可用性。

#### Raft和Paxos

###### Paxos

- Paxos 的核心思想是通过多个阶段的交互来使不同节点达成一致。算法中涉及三个主要角色：提议者（Proposer）、接收者（Acceptor）和学习者（Learner）。Paxos的基本流程如下：

1. **Prepare 阶段：** 提议者向接收者发送一个编号（提案号），要求接收者准备投票。接收者比较提案号，并根据规则进行投票。
2. **Promise 阶段：** 如果接收者接受提案号，它就会向提议者发送一个承诺，表示不再接受更小编号的提案。如果接收者已经承诺了更大编号的提案，它就会忽略这次投票请求。
3. **Accept 阶段：** 提议者在收到足够数量的承诺后，选择一个值（提案），然后向接收者发送请求接受该提案。接收者会根据提案号进行比较，如果接受提案则广播给学习者。
4. **Learn 阶段：** 学习者会在接收到足够数量的接受通知后，确认某个值已被接受。学习者确保多数派已接受同一个提案，从而达成一致。

###### Raft

- Raft 的核心思想是将分布式一致性问题分解为三个相对独立的部分：领导选举（Leader Election）、日志复制（Log Replication）和安全性（Safety）。这种拆分使得算法的设计和实现更加清晰明了。以下是 Raft 的主要概念和步骤：

1. **领导选举：** 在 Raft 中，每个节点可以是三种状态之一：跟随者（Follower）、候选人（Candidate）和领导者（Leader）。初始状态下，所有节点都是跟随者。如果一个跟随者长时间未收到领导者的消息，它会变为候选人，发起选举。候选人向其他节点发起投票请求，获得多数票后，成为领导者。
2. **日志复制：** 领导者负责接收客户端的操作请求，并将操作封装成日志项，然后广播给其他节点。一旦大多数节点确认接受了这个日志项，领导者可以将这个日志项应用到状态机，实现数据的复制和一致性。
3. **安全性：** Raft 保证数据一致性的基本原则是要求一条日志项只有在大多数节点确认后才能被提交。这确保了在任何情况下只有正确的日志项被提交到状态机。

#### 分布式事物

1. **两阶段提交（Two-Phase Commit，2PC）**： 2PC 是一种最经典的分布式事务协议。它分为两个阶段：准备阶段和提交阶段。所有参与者首先在准备阶段确认是否可以提交事务，然后在提交阶段进行实际的提交。虽然2PC确保了事务的一致性，但是其在网络分区等情况下可能导致阻塞问题，从而影响性能和可用性。
2. **三阶段提交（Three-Phase Commit，3PC）**： 3PC是在2PC的基础上改进而来，引入了准备阶段的超时机制，从而一定程度上缓解了2PC中可能出现的阻塞问题。但是它仍然无法解决所有的分布式事务问题。
3. **Saga 模式**： Saga是将大事务拆分为多个小事务，每个小事务都有相应的补偿操作。当一个小事务失败时，它会调用前面已经执行的事务的补偿操作，从而保证整体一致性。Saga模式的优势在于部分失败时可以部分回滚，但实现复杂性较高。
4. **TCC（Try-Confirm-Cancel）**： TCC是另一种分布式事务的解决方案，将事务拆分为三个阶段：尝试、确认、撤销。每个阶段都有对应的操作，允许开发人员在每个阶段定义逻辑。TCC的实现需要开发者编写明确的业务逻辑，以确保事务的正确执行和回滚。
5. **异步消息补偿**： 该方案通过将事务操作转化为消息，然后将消息发送到消息队列中。当事务成功后，消息将被处理；如果事务失败，消息将被忽略或标记为错误。这种方式减少了事务的同步等待，但需要确保消息队列的可靠性。
6. **分布式数据库事务**： 一些数据库引擎（如分布式数据库）提供了内置的分布式事务支持，允许跨多个节点的事务操作。例如，Google Spanner 和 CockroachDB 提供了分布式事务支持。
7. **基于时间戳的方案**： 一些方案利用全局唯一的时间戳来协调跨节点的事务，例如 Google TrueTime。

#### REST 与 RPC协议

（1）REST：
        REST 是基于 HTTP 实现，使用 HTTP 协议处理数据通信，更加标准化与通用，因为无论哪种语言都支持 HTTP 协议。常见的 http API 都可以称为 Rest 接口。REST 是一种架构风格，指一组架构约束条件和原则，满足 REST 原则的应用程序或设计就是 RESTful，RESTful 把一切内容都视为资源。REST 强调组件交互的扩展性、接口的通用性、组件的独立部署、以及减少交互延迟的中间件，它强化安全，也能封装遗留系统。

（2）RPC：
        RPC 是一种进程间通信方式，允许像调用本地服务一样调用远程服务，通信协议大多采用二进制方式。

![image-20230222224141862](C:\Users\hua'wei\AppData\Roaming\Typora\typora-user-images\image-20230222224141862.png)

#### RPC框架模块

一个RPC框架通常需要以下模块：

1. 服务接口定义语言（IDL）：定义服务接口的语言，通常使用IDL语言来定义接口和数据结构，以确保客户端和服务端之间的通信可以正确地序列化和反序列化。
2. 序列化/反序列化模块：将请求和响应数据序列化为二进制流，以便在网络上传输，并在接收端将其反序列化为原始数据。
3. 传输模块：负责将序列化后的数据在客户端和服务端之间进行传输。传输模块通常使用TCP或UDP协议进行通信。
4. 服务注册与发现模块：服务注册与发现模块用于将服务注册到注册中心，并从注册中心查询可用的服务实例。常见的服务注册与发现框架包括Zookeeper、Consul等。
5. 负载均衡模块：负载均衡模块用于将客户端请求分配到可用的服务实例上。负载均衡算法通常包括轮询、随机、最少连接数等。
6. 服务容错和监控模块：服务容错和监控模块用于监控服务实例的状态，并在服务实例不可用时进行容错处理，例如重试、降级等。

#### 负载均衡算法

1. 轮询算法（Round Robin）：将请求依次分配给每个服务器，直到所有服务器都被分配了一次请求，然后重新开始循环。这种算法适用于服务器的性能相近的情况。
2. 随机算法（Random）：将请求随机分配给服务器。这种算法简单易行，但可能会导致某些服务器的负载过高。
3. 最少连接算法（Least Connections）：将请求分配给当前连接数最少的服务器。这种算法可以避免某些服务器的负载过高，但需要实时监控每个服务器的连接数。
4. IP哈希算法（IP Hash）：根据请求的来源IP地址，将请求分配给固定的服务器。这种算法适用于需要保持会话的应用程序，但可能会导致某些服务器的负载过高。
5. 加权轮询算法（Weighted Round Robin）：将请求按照权重分配给服务器。权重越高的服务器会获得更多的请求。这种算法适用于服务器性能不同的情况。
6. 加权最少连接算法（Weighted Least Connections）：将请求按照权重分配给连接数最少的服务器。权重越高的服务器会获得更多的请求。这种算法适用于服务器性能不同的情况，并且需要实时监控每个服务器的连接数。

#### Nacos原理

###### 服务注册与发现

- 服务提供者在启动时向 Nacos 注册自己的服务信息，包括服务名称、IP 地址、端口等。
- 服务消费者通过 Nacos 查询特定服务的实例列表，以便进行负载均衡和服务调用。
- Nacos 支持多种方式的服务注册和发现，包括基于 DNS 解析、HTTP/REST 和 gRPC 等。

###### 动态配置管理

- Nacos 提供了配置中心，用于管理应用程序的配置信息。
- 应用程序可以从 Nacos 获取配置，Nacos 支持配置的动态刷新，使得配置变更时应用程序可以实时感知并更新。
- Nacos 支持多种配置数据类型，如文本、JSON、XML 等。

###### 服务健康监测

- Nacos 可以定时检查注册在其中的服务实例，判断它们的健康状态。
- 基于健康检查的结果，Nacos 可以自动从服务注册表中剔除不健康的实例，确保客户端不会调用到不可用的服务。

###### 集群和高可用

- Nacos 支持多实例部署，构建高可用的集群架构。
- 通过多实例的部署，Nacos 可以在节点故障时继续提供服务，保证系统的可靠性和稳定性。

###### 持久化和一致性

- Nacos 使用存储层来持久化注册的服务信息和配置数据。
- 在存储方面，Nacos 支持多种存储后端，如 MySQL、Derby 和 RocksDB 等。
- Nacos 通过 Raft 算法来保证数据的一致性，确保数据在集群中的复制和同步。

#### Ribbon原理

客户端负载与均衡、动态更新、容错和重试

###### IRule

`IRule` 是 Ribbon 框架中的一个接口，用于定义客户端负载均衡的规则。通过实现 `IRule` 接口，你可以自定义负载均衡策略，从而根据自己的需求选择服务实例。Ribbon 提供了一些默认的实现，比如随机、轮询、权重等策略，但你也可以根据实际情况编写自己的规则。

#### Gateway原理

Spring Cloud Gateway 作为一个反应式网关，通过使用 Reactor 提供的异步、非阻塞的编程模型，实现了高性能和高并发的特点。它可以接收客户端请求，根据配置的路由规则将请求转发到不同的服务实例，同时可以通过过滤器进行请求和响应的处理。

###### 执行流程

1. **客户端发起请求：** 客户端发送请求到 Spring Cloud Gateway。
2. **路由匹配：** Gateway 接收到请求后，会根据事先配置的路由规则进行匹配。路由规则定义了请求的 URI、Host 等信息与目标服务的映射关系。
3. **负载均衡选择服务实例：** 一旦匹配到路由规则，Gateway 将根据负载均衡策略选择目标服务的一个实例。这可以通过 Ribbon 等负载均衡器来实现。
4. **执行过滤器：** 在请求转发到目标服务实例之前，会经过一系列的过滤器。过滤器可以用于在请求前后进行处理，如鉴权、日志记录、请求修改等。
5. **转发请求：** 经过过滤器处理后，Gateway 会将请求转发到选定的目标服务实例。
6. **接收响应：** 目标服务实例处理请求并返回响应。Gateway 接收响应后，同样会经过一系列的过滤器，进行响应处理。
7. **返回响应：** 最终，Gateway 将处理后的响应返回给客户端。

#### Nginx自动故障转移

1. **负载均衡器配置**： 在 Nginx 配置中设置负载均衡器，将请求分发到多个后端服务器。可以使用 Nginx 自带的 `upstream` 模块配置负载均衡组。
2. **健康检查脚本**： 创建一个健康检查脚本，用于定期检查后端服务器的健康状态。这个脚本可以通过检查服务器的响应状态码、延迟等指标来判断服务器的健康程度。
3. **故障检测与切换**： 将健康检查脚本集成到一个自动化工具中，该工具可以监视后端服务器的健康状态。如果某个服务器被标记为不健康，这个工具可以更新 Nginx 的配置文件，将故障的服务器从负载均衡组中移除。
4. **Nginx 配置刷新**： 配合健康检查工具，可以使用 Nginx 的信号处理方式实现配置的动态刷新。通常，使用 `nginx -s reload` 命令可以重新加载配置文件，使得修改生效，但请注意在配置文件中进行更改之前，要确保新配置的正确性。

#### Docker命令

1. **docker pull <image_name>[:tag]**：从 Docker 镜像仓库下载指定的镜像。
2. **docker images**：列出本地已下载的 Docker 镜像。
3. **docker run <options> <image_name>**：基于指定的镜像创建并运行一个容器。
4. **docker ps**：列出正在运行的容器。
5. **docker ps -a**：列出所有容器，包括已经停止的容器。
6. **docker start <container_id or name>**：启动一个已停止的容器。
7. **docker stop <container_id or name>**：停止一个正在运行的容器。
8. **docker restart <container_id or name>**：重启一个容器。
9. **docker rm <container_id or name>**：删除一个已停止的容器。
10. **docker exec -it <container_id or name> <command>**：在正在运行的容器中执行指定的命令。
11. **docker logs <container_id or name>**：查看容器的日志输出。
12. **docker build -t <image_name>:<tag> <path_to_dockerfile>**：基于 Dockerfile 构建一个新的镜像。
13. **docker push <image_name>:<tag>**：将本地的镜像推送到 Docker 镜像仓库。
14. **docker network ls**：列出所有 Docker 网络。
15. **docker volume ls**：列出所有 Docker 数据卷。
16. **docker-compose up**：使用 Docker Compose 启动一组定义在 `docker-compose.yml` 文件中的服务。
17. **docker-compose down**：使用 Docker Compose 停止并删除一组服务。

#### ElasticSearch

文档：每条数据就是一个文档

词条：文档按语义分成的词语

索引：相同类型的文档的集合

映射：索引中文档的字段约束信息，类似表的结构约束

###### 倒排索引

1. **词典（Dictionary）**：词典是一个将词语映射到词项（term）的数据结构。每个词项包含了相关的信息，如词频、文档频率等。词典帮助系统查找并了解每个词语在索引中的位置。
2. **倒排列表（Posting List）**：每个词项都关联一个倒排列表，它包含了包含该词语的所有文档的信息。这些信息可能包括文档ID、词频、位置等。倒排列表的结构允许系统快速地定位相关文档。

###### 分片和副本

1. **分片（Shard）**：

	分片是将索引数据分割成更小的片段，以便将数据分布在多个节点上。每个分片是一个独立的索引，包含一部分数据。分片的主要目的是实现数据水平分布和并行处理，从而提高查询性能和吞吐量。

	在创建索引时，您可以指定要创建的分片数。分片数在索引创建后通常是固定的，不太容易更改。数据被均匀分布到这些分片中，以实现负载均衡和扩展性。分片数的选择需要根据数据量、硬件性能和查询需求进行权衡。

2. **副本（Replica）**：

	副本是分片的复制品，它提供了数据的冗余备份和负载均衡。每个分片可以有零个或多个副本。副本分布在不同的节点上，以确保在某个节点出现故障时数据仍然可用。

	副本有助于提高系统的可用性和容错性。如果主分片不可用（因为节点故障等原因），副本分片可以被提升为主分片，以继续提供服务。此外，多个副本可以同时响应读请求，从而提高读取操作的性能。

	副本数的选择需要考虑可用性、性能和资源消耗。副本越多，可用性越高，但同时也会占用更多的存储和计算资源。

###### 分布式搜索

1. **数据分布**：数据被分割成多个分片，并在多个计算节点上进行存储。每个分片包含一部分数据，并且可以在不同的节点上复制以提供冗余备份。
2. **查询并行处理**：查询被分发到多个分片上并行执行。每个分片独立处理自己的部分数据，然后将结果合并返回给用户。这样可以加快查询速度，特别是对于大规模数据集。
3. **负载均衡**：分布式搜索引擎可以自动管理查询的负载均衡。它会根据节点的负载情况将查询分发到最合适的节点上，避免某些节点过载。
4. **故障容错**：由于数据被复制到多个节点，当某个节点出现故障时，系统仍然可以继续处理查询，从其他副本中获取数据。这提高了系统的可用性和容错性。
5. **可扩展性**：分布式搜索引擎允许动态地添加新的节点，从而扩展系统的性能和容量。这种扩展性使系统能够适应不断增长的数据和用户负载。
6. **分布式索引和查询优化**：分布式搜索引擎需要考虑索引和查询在分布式环境中的优化。例如，在索引时如何合理地划分数据、如何最小化网络通信等问题。

###### ES聚合

聚合功能不仅仅是简单的计数或汇总操作，它可以在数据集上执行各种计算操作，如统计、分布、百分比、平均值、最大/最小值、关联分析等。这些操作可以用于构建仪表盘、报表、数据可视化以及更复杂的数据分析任务。

1. **桶聚合（Bucket Aggregations）**：
	- **Terms Aggregation**：将结果分组到不同的“桶”中，每个桶代表一个唯一的值或范围。
	- **Date Histogram Aggregation**：将时间序列数据按照时间间隔分桶，创建时间范围的桶。
	- **Range Aggregation**：将数值字段的数据分组为不同的范围桶。
	- **Geo Distance Aggregation**：将地理位置数据按距离分桶。
2. **指标聚合（Metric Aggregations）**：
	- **Sum Aggregation**：计算数值字段的总和。
	- **Avg Aggregation**：计算数值字段的平均值。
	- **Max/Min Aggregation**：找出数值字段的最大/最小值。
	- **Stats Aggregation**：计算数值字段的统计信息，包括总和、平均、最大、最小和样本数量。
3. **嵌套聚合（Nested Aggregations）**：
	- 在一个聚合内嵌套另一个聚合，以支持更复杂的数据分析。
4. **Pipeline Aggregations**：
	- 在已经进行聚合的结果上执行后续的计算，如计算聚合结果的移动平均值。

#### 单点登录

1. **选择认证协议：** 选择适合你需求的认证协议，常用的包括OAuth、OpenID Connect和SAML等。这些协议允许用户在一个认证服务中登录，然后可以访问其他关联的应用程序。
2. **设计认证中心：** 创建一个认证中心，它负责验证用户的凭据并颁发令牌。这个中心将会成为单点登录系统的核心。你可以使用现有的认证中心软件，如Keycloak、Auth0等，或者自行实现。
3. **集成应用程序：** 集成需要单点登录的应用程序。每个应用程序都需要向认证中心注册，并配置为信任该中心颁发的令牌。这些应用程序在收到令牌后，可以使用认证中心验证令牌的有效性，从而确认用户的身份。
4. **实现令牌传递：** 用户在认证中心登录后，认证中心会颁发一个令牌。当用户访问其他应用程序时，令牌会被传递给这些应用程序，这样它们可以验证用户的身份而无需再次登录。
5. **单点注销：** 实现单点注销（Single Logout）功能，确保用户在一个应用程序注销后，所有关联的应用程序也会注销用户，保持一致的会话状态。