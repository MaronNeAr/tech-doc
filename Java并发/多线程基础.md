#### 多线程基础

###### 守护线程

- 守护线程：守护线程是在程序运行时在后台提供服务的线程。

- 非守护线程：非守护线程是程序的主要执行线程，当所有的非守护线程结束后，程序会等待所有守护线程执行完毕才会退出。

###### 阻塞

- 轻量级阻塞：可以被中断的阻塞，对应的线程状态是WAITING（无限阻塞）或者TIMED_WAITING（按传入时间有限阻塞）
- 重量级阻塞：不能被中断的阻塞，对应的线程状态是BLOCK
- interpret函数：唤醒轻量级阻塞，如果线程正处于WAITING或者TIMED_WAITING状态时，便会抛出InterruptedException

###### 锁

- 这个对象内部得有一个标志位(state变量)，记录自己有 没有被某个线程占用(也就是记录当前有没有游客已经进入了房 子)。最简单的情况是这个state有0、1两个取值，0表示没有线程占 用这个锁，1表示有某个线程占用了这个锁。

- 如果这个对象被某个线程占用，它得记录这个线程的thread ID，知道自己是被哪个线程占用了(也就是记录现在是谁在房子里 面)。

- 这个对象还得维护一个thread id list，记录其他所有阻塞的、等待拿这个锁的线程(也就是记录所有在外边等待的游客)。在当前线程释放锁之后(也就是把state从1改回0)，从这个thread id list里面取一个线程唤醒。

###### synchronized原理

- **底层**：Java的对象头当中，有一块叫做Mark Word，包括锁标志位和Thread ID
- **锁的获取与释放**：`synchronized` 关键字通过锁的机制来实现线程同步。当一个线程进入被 `synchronized` 修饰的代码块或方法时，它会尝试获取锁。如果锁没有被其他线程占用，那么当前线程将获得锁，并进入临界区执行代码；如果锁已经被其他线程占用，那么当前线程将被阻塞，等待锁的释放。
- **锁的释放**：当线程执行完 `synchronized` 代码块或方法时，它会释放锁，使得其他等待的线程有机会获取锁进入临界区。
- **锁的可重入性**：Java 中的锁是可重入的，即同一个线程可以多次获取同一个锁而不会死锁。这样可以确保在同一线程中嵌套调用 `synchronized` 代码块时，线程能够正常执行而不被阻塞。
- **锁的粒度**：`synchronized` 可以用于不同粒度的同步，包括对象级别的同步、方法级别的同步和静态方法级别的同步。锁的粒度的选择要根据实际情况，避免过大或过小导致性能问题。

###### synchronized底层实现

**Java 对象头（Object Header）**：

每个 Java 对象在内存中都有一个对象头，其中包含了一些用于存储对象元数据的信息。其中涉及到 `synchronized` 的信息有两个重要的字段：

1. **Mark Word（标记字段）**：在对象头的 Mark Word 中包含了一些标记位，其中的一些位用于存储锁的信息。具体包括是否被锁定、锁的持有者线程的标识等。
2. **指向监视器的指针**：对象头还包含了指向监视器（Monitor）的指针，该监视器用于管理对象的锁信息。

**监视器（Monitor）**：

监视器是与对象关联的锁，用于控制对对象的并发访问。每个 Java 对象都与一个监视器关联。在 `synchronized` 的实现中，监视器有两种状态：无锁状态和锁定状态。

1. **无锁状态**：表示对象没有被线程锁定，任何线程都可以访问。
2. **锁定状态**：表示对象已经被某个线程锁定，其他线程需要等待。

**synchronized 的实现过程**：

1. 当一个线程进入 `synchronized` 代码块或方法时，首先会尝试获取对象的锁。
2. 如果对象的锁是无锁状态，当前线程将成功获取锁，

###### wait()和notify()

1. **`wait` 方法**：
   - **作用**：`wait` 使当前线程进入等待状态，同时释放它所持有的对象锁。
   - **原理**：当线程调用 `wait` 时，它会释放对象锁，然后进入等待队列，等待其他线程通过 `notify` 或 `notifyAll` 方法来唤醒它。
   - **使用场景**：通常在多线程协作的场景中，当某个条件不满足时，线程调用 `wait` 进入等待状态，直到其他线程修改了条件并调用了 `notify` 来唤醒等待线程。
2. **`notify` 方法**：
   - **作用**：`notify` 用于唤醒一个正在等待的线程，将其从等待队列中移动到锁定池中。
   - **原理**：当线程调用 `notify` 时，它会唤醒等待队列中的一个线程（具体唤醒哪个线程是不确定的），将其移动到锁定池中，使其具备获取对象锁的资格。
   - **使用场景**：通常在某个条件得到满足时，线程调用 `notify` 来唤醒等待的线程，使其继续执行。
3. **`notifyAll` 方法**：
   - **作用**：`notifyAll` 用于唤醒所有正在等待的线程。
   - **原理**：与 `notify` 类似，但是它会唤醒等待队列中的所有线程，将它们移动到锁定池中。
   - **使用场景**：当某个条件得到满足，可能唤醒多个线程时，可以使用 `notifyAll`。

###### volatile

- 内存不可见：一个线程写完后，另一个线程立即读可能会是之前的结果，是“最终一致性”，不是“强一致性”
- 内存可见性：线程写完后立即对其他线程可见
- 禁止重排序：DCL会使系统底层优化，进行指令重排序，volatile禁止重排序底层运用了内存屏障

###### JMM概念和规则

1. **主内存（Main Memory）**：
   - 所有线程共享的内存区域，包含所有的实例变量和静态变量。
   - 主内存是所有线程访问共享数据的地方。
2. **工作内存（Working Memory）**：
   - 每个线程独有的、与主内存内容相对应的内存区域。
   - 线程的操作和对变量的修改首先在工作内存中进行，然后才会同步到主内存中。
3. **原子性（Atomicity）**：
   - JMM 保证将基本数据类型的读取和写入操作视为原子操作。这意味着一个线程对变量的修改对其他线程是立即可见的。
4. **可见性（Visibility）**：
   - 当一个线程修改了共享变量的值，这个新值对其他线程是不一定可见的。为了确保可见性，需要使用 `synchronized` 或 `volatile` 等同步机制。
5. **有序性（Ordering）**：
   - JMM 不保证线程执行语句的顺序与程序代码中的顺序一致。在没有同步措施的情况下，不同线程可能观察到的操作顺序是不同的。
   - 通过同步机制（例如 `synchronized` 或 `volatile`）可以保证操作的有序性。

- 重排序
  - 编译器重排序。对于没有先后依赖关系的语句，编译器可以 重新调整语句的执行顺序。
  - CPU指令重排序。在指令级别，让没有依赖关系的多条指令 并行。
  - CPU内存重排序。CPU有自己的缓存，指令的执行顺序和写入 主内存的顺序不完全一致。
  
  - as-if-serial：保证每个线程内部都是“看似完全串行的”。但多个线程会互相读取和写入共 享的变量，对于这种相互影响，编译器和 CPU 不会考虑。

###### happen-before执行规则

1. **程序顺序规则**：
   - 在一个线程内，每个操作按照程序代码的顺序执行。这确保了在单个线程中的操作是有序的。
2. **锁定规则**：
   - 一个解锁操作 `unlock` 必定发生在后续的相同锁的锁定操作 `lock` 之前。这确保了对于共享资源的操作的顺序。
3. **volatile变量规则**：
   - 对于一个 `volatile` 变量的写操作必定发生在后续对该变量的读操作之前。这确保了对 `volatile` 变量的可见性。
4. **传递性**：
   - 如果操作 A `happen-before` 操作 B，且操作 B `happen-before` 操作 C，则操作 A `happen-before` 操作 C。这确保了操作之间的传递性。
5. **线程启动规则**：
   - 线程的启动（start）操作必定发生在被启动线程的所有操作之前。这确保了新线程的操作不会与旧线程的操作发生冲突。
6. **线程终止规则**：
   - 线程的所有操作必定发生在其终止（join）操作之前。这确保了主线程可以看到子线程的操作。
7. **线程中断规则**：
   - 对线程的中断（interrupt）操作必定发生在被中断线程的操作之前。这确保了中断能够及时被处理。

###### 内存屏障

- JMM和happen-before的底层实现机制
- 为了告诉编译器不要对指令进行重排序。当编译完成之后，这种内存屏障就消失了，CPU并不会感知到编译器中内存屏障的存在。

- Unsafe内存屏障
  - LoadLoad:禁止读和读的重排序。 
  - StoreStore:禁止写和写的重排序。
  - LoadStore:禁止读和写的重排序。
  - StoreLoad:禁止写和读的重排序。
